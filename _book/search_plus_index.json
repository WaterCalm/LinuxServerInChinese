{"./":{"url":"./","title":"前言的前言","keywords":"","body":"前言的前言 Docker在手，天下我有 自从接触了Docker越来越喜欢这个东西了。简而言之就是部署简单，很适合新手或者像我这样的菜鸟去快速部署自己想要的服务来达到自己的目的。 比如，你家里有一个NAS，按平常来说它也只能安安静静地躺在家里，只能等待你回家后才能宠幸它。如果有了Docker，你可以轻松地搭建一个NextCloud再配合ddns，你就可以随时随地宠幸您的NAS。什么？你说NAS服务商提供了远程访问服务？那你可以再看看那高昂的服务费和上传下载的龟速，配得上你每年花费千余元办理的宽带吗？ 再比如，你想呼朋引伴一起Happy，奈何大家又天南海北。如果有了Docker，你可以轻松地搭建一个Minetest服务器。大家一起去你的服务器上玩游戏，这感觉是不是倍儿爽？ 再比如，你喜欢记笔记，但又觉得那些云服务不好用或不安全，更或者说你想记一些私密到极致的东西。如果有了Docker，你可以轻松地搭建一个BookStack。别说记笔记了，写出一部长篇巨著也是指日可待。 再比如，虽然你现在正在干着碌碌无为的工作，但你心怀科幻对核物理、量子世界充满着好奇。如果有了Docker，你可以轻松地搭建一个boinc。在boinc上为全国乃至全世界的科研机构贡献一下你过剩的计算资源，或许有一天某个重要的科研成果的背后就有你贡献的计算结果。 再比如……再多的比如，都不如自己亲自动手试一下，体验一下“Docker在手，天下我有”！ LinuxServer.io Docker这东西最重要的就是镜像（image），LinuxServer则维护、发布了大量的开源软件的Docker镜像。可以理解为这个组织是Docker界的小米，在它出现之前Docker镜像的质量参差不齐标准不一，而LinuxServer则将一批优质的开源软件制作成Docker镜像并统一标准，能让广大拥有家庭服务器的小白和非专业爱好者们通过Docker充分体验什么叫科技改变世界。 那我要做什么？ 也许是因为国内Docker用户还主要局限于企业以及专业人士，也许国内的家庭服务器（或NAS）的普及度还没那么高，很少能找到Docker对普通用户的意义，甚至百度“有趣的Docker镜像”也只是零星的几篇文章。所以我打算新建一个GitBook翻译一下LinuxServer.io的文档和他们发布的镜像，希望能帮到有需要的人。 当然，我也是一个小白，在翻译的过程中我可能并不会完全按照原文进行翻译，其中也会加入自己的理解和注释。如果出现不是特别准确的地方，还请各位大佬指正。除此之外，我也会尽可能地实际使用每个镜像，并介绍镜像的作用，有机会的话还会提供demo地址。 因为LinuxServer官方的文档不包括Docker的安装以及适合小白的Portainer安装所以我会在正式开始之前先进行一些补充。感兴趣的可以先看安装Docker、Portainer-可视化管理Docker这两篇文章后再去看前言。 powered by Gitbook该页面修订时间： 2020-10-16 12:09:06 "},"before/docker-install.html":{"url":"before/docker-install.html","title":"安装Docker","keywords":"","body":"安装Docker 使用脚本安装Docker Linux安装 Docker官方为了简化安装流程，提供了一套安装脚本，可以直接在终端中执行下面这条命令 curl -sSL https://get.docker.com/ | sh 如果在国内直接这么用可能会被感人的网速感动到，可以在后面加上阿里云的镜像。 curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun 当然，也可以用DaoCloud提供的安装脚本 curl -sSL https://get.daocloud.io/docker | sh 阿里云的官方也提供了一个安装脚本 curl -sSL http://acs-public-mirror.oss-cn-hangzhou.aliyuncs.com/docker-engine/internet | sh 安装过程中只需要静静地等待即可…… Windows & macOS安装 对于Windows和macOS来说，只要去docker的官网下载对应系统的版本就好。 → Docker Get Started 但我强烈不建议在Windows上安装docker，总会遇到各种各样奇奇怪怪的问题。我曾在两台不同的Windows电脑上安装过Docker，最后都毅然决然地卸载了。如果在Windows平台，可以尝试使用Windows的Linux子系统功能来体验Docker。 → 适用于 Linux 的 Windows 子系统文档 配置镜像加速 安装完成后，我是都习惯于修改下镜像源，不然有可能遇到网络问题。 可以使用DaoCloud提供的脚本来添加镜像源，可以把最后的加速地址换成自己的 curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://f1361db2.m.daocloud.io 也可以参照阿里云提供的方式手动设置（阿里云容器镜像服务） sudo mkdir -p /etc/docker sudo tee /etc/docker/daemon.json 其实很简单，docker会读取在/etc/docker目录下的daemon.json文件作为配置。默认是没有这个文件的，新建一个就好，之后再用docker pull镜像的时候，就会从镜像源去拉取，提升了速度与稳定性。 到此为止，docker的安装就完成了。 powered by Gitbook该页面修订时间： 2020-10-16 14:17:58 "},"before/portainer.html":{"url":"before/portainer.html","title":"Portainer - 可视化管理Docker","keywords":"","body":"Portainer - 可视化管理Docker Portainer是一个优秀的Docker、Swarm、Kubernetes等容器服务的管理工具，拥有简单明了的UI界面。这里我们只要知道这东西可以可视化管理Docker就好，功能很强大，但对于我们小白来说最直观的感受就是告别了黑白的命令行。 拉取镜像 拉取镜像前，我们可以先去 Docker Hub 搜索一下，一般来说在这里都能找到对应镜像的文档。https://hub.docker.com/ [!WARNING] portainer/portainer 镜像目前已不被推荐使用，应该使用 portainer/portainer-ce 镜像 在命令行下拉取镜像，如果非root用户或者提示权限问题，记得在命令前加上 sudo docker pull portainer/portainer-ce 部署镜像 因为portainer需要一个卷（volume）来保存配置和相关数据，我们可以用docker创建一个匿名卷，也可以选择挂载一个本地的目录。 [!NOTE] 官方的提供的部署命令中除了开放9000端口外，还开放了8000端口。但我们只通过浏览器访问portainer，所以只开放9000端口即可。 #创建匿名卷 docker volume create portainer_data #部署容器 docker run -d -p 9000:9000 --name=portainer -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce 如果想挂载到本地目录只需要把 portainer_data 修改为本地的绝对路径即可。 docker的部署命令中，涉及到端口和卷的映射时，都是这种格式 宿主机:容器内 。 [!TIP] 建议大家把docker容器的部署命令写在一个 shell 文件中，并赋予文件执行权限。这样如果日后需要更新容器或者重新部署的时候，只要运行这个shell文件即可。 #创建文件 nano portainer.sh #把命令写入文件，可以用这种格式方便阅读，记得每行结尾要有“ \\”，不然会报错 docker run -d \\ -p 9000:9000 \\ --name=portainer \\ -v /var/run/docker.sock:/var/run/docker.sock \\ -v /docker/portainer:/data \\ portainer/portainer-ce #写入完成后保存，nano编辑器就是 ctrl+o写入，ctrl+x退出。vi编辑器则是 按esc后输入 :wq #赋予脚本执行权限 chmod +x portainer.sh #执行脚本部署容器 ./portainer.sh 部署成功后，会返回容器的id。 然后我们在浏览器中输入 http://ipaddress:9000 即可访问portainer的WEB UI界面 之后，我们按照界面的提示创建管理员账号、选择本地容器就可以进入主界面了。 powered by Gitbook该页面修订时间： 2020-10-16 16:12:50 "},"before/dockerabc.html":{"url":"before/dockerabc.html","title":"关于Docker的几点常识","keywords":"","body":"关于Docker的几点常识 Docker几个概念的简单介绍 为了方便小白，简单介绍下后面文章中会提到的几个概念： 中文名称 英文 参数 介绍 镜像 image 可以理解为别人制作好的安装包 容器 container 通过 docker run 或 docker create 命令即可部署镜像，随之成为容器并运行在你的电脑上 卷 volume -v 在部署镜像的时候通过 -v 来设置，即可把宿主机上的路径映射到容器内。也可以通过 docker volume create 来创建匿名卷存储相关的数据。 环境变量 environment -e 即容器内的环境变量，在部署的时候通过 -e 来设置，容器内可以通过 env 查看。 端口 port -p 可以将容器内的某个端口映射到宿主机上 网络 network --network 可以将多个容器设置在同一个网络下，方便各个容器之间的网络通信，这样也不必要将每个端口都开放到宿主机上。如果要给容器绑定ip则必须要先创建网络才行。 创建虚拟网络 在实际应用中我们会遇到不同容器之间需要进行网络通信。比如搭建nextcloud，可能需要mariadb、nextcloud、nginx三个容器一起运行，这时就需要将这三个容器分别绑定一个固定ip，不然重启电脑或者重启docker的时候因容器的启动顺序不同，会造成他们在容器内的ip改变，造成服务报错。 如果要给容器绑定固定ip，需要先创建网络（官方文档）： docker network create --driver=bridge --subnet=10.0.0.0/24 myNetwork 其中 --subnet 是ip/掩码位 格式，可以指定创建的网络的IP段，具体可以通过 IP地址在线计算器 了解。当然，也可以不指定这个参数，那么docker将默认分配一个IP段。 创建好虚拟网络之后，我们在部署镜像的时候就可以通过 --network 和 --ip 来给容器指定网络和IP。 当然，如果你已经安装了portainer的话。也可以直接通过web ui来创建网络 powered by Gitbook该页面修订时间： 2020-10-16 14:19:24 "},"Introduction.html":{"url":"Introduction.html","title":"前言","keywords":"","body":"前言 [!NOTE] 以下内容开始便是翻译自LinuxServer.io官网的文档内容 欢迎大家阅读LinuxServer.io的文档。在这里，我们将记录镜像的相关信息，以帮助我们的用户入门使用。除了针对每个容器的设置指南外，我们还会简要介绍docker的使用，以及一些实践案例。 如何与我们交流？ 我们主要在 Discord 1上交流，也可以在论坛上与我们交流。 Discord → https://discord.gg/YWrKVTn 论坛 → https://discourse.linuxserver.io 如果对我们的持续集成（CI）环境感兴趣，可以浏览我们的 Jenkins2 ：https://ci.linuxserver.io/ 1. 一款即时通信软件，可以通过网页直接访问。（可能需要科学上网） ↩ 2. 基于Java开发的一种持续集成工具，用于监控持续重复的工作。 ↩ powered by Gitbook该页面修订时间： 2020-10-16 12:33:52 "},"general/container-execution.html":{"url":"general/container-execution.html","title":"进入容器","keywords":"","body":"进入容器 在使用Docker的过程中，你也许会想要查看容器内部的数据。 进入容器内的Shell 在部署、调试容器的时候，经常会需要进入到容器内的Shell。 # 替换 为容器的名称 docker exec -it /bin/bash 查看容器的日志（logs） 我们绝大多数的镜像都会把应用的运行日志输出到终端上，可以使用 docker logs 命令来查看： # 替换为你希望查看日志的行数 # 替换为容器名 docker logs -f --tail= 默认情况下，docker会输出容器的所有日志，所以通过 --tail 参数来限制输出的日志行数。 为了更方便使用这条命令，也可以通过编辑 ~/.bash_aliases 文件来自定义一条命令： # ~/.bash_aliases alias dtail='docker logs -tf --tail=\"50\" \"$@\"' 之后只需要执行 dtail 就可以了。 查看构建的版本号 如果您在使用的过程中遇到了某些问题，您可以把版本号反馈给我们，也许我们在已发布的新版本中解决了您的问题。当然如果您反馈给我们的已经是最新的版本号，那您可能发现了我们还未发现的问题。提供正确的版本号将有助于我们修复镜像的问题，也会更加方便解决您遇到的问题。 可以通过这条命令获取容器的版本号： # 替换 为容器的名称 docker inspect -f '{{ index .Config.Labels \"build_version\" }}' 如果获取镜像的版本号，则是： # 替换 为容器的名称 docker inspect -f '{{ index .Config.Labels \"build_version\" }}' linuxserver/ [!TIP] 如果你已经按照 Portainer-可视化管理Docker 这篇文章所述安装了portainer，那么你也可以在容器的管理页面的“Container details”面板的“Labels”中看到容器的版本号 powered by Gitbook该页面修订时间： 2020-10-16 14:30:52 "},"general/containers-101.html":{"url":"general/containers-101.html","title":"Docker容器入门","keywords":"","body":"Docker容器入门 Docker容器中已经包含了内置应用的所有以来，所以用户不必再去考虑需要什么版本的Java、Apache或其他什么东西，因为这些东西已经被镜像的制作者打包进去了。除此之外，容器通常是不包括应用相关的配置文件的，这主要是因为容器的内部是“无状态”和“一成不变”的。换句话说，容器创建后最好不要修改容器内的文件。 [!NOTE] 其实确切来说并非是容器内的文件不能修改，而是改了也没用。即使进入容器内部修改了某个文件，当想要修改环境变量、卷、端口等设置时，容器就会恢复到最初镜像里的内容，导致修改了也没用。除非这个容器一直能良好运行，但这个谁又能保证呢？ 如果真的需要修改容器内的某个依赖或者配置，可以使用 docker commit 重新提交成镜像，或者干脆用Dockerfile重新构建一个新的镜像。 我都需要了解哪些内容？ 如果仅是上手，不需要了解太多。只要了解一些用于执行复杂操作和排除故障的术语和概念就行了，但如果要入门就没这么简单了。 docker run hello-world 就这简单的一句命令，你便已经运行了你的第一个容器（当然前提是你已经安装了docker）。Docker容器最大的优势就是，您不必知道容器内的程序是如何运行的只要这么一句命令就可以运行它。虽然 hello-world 只是一个很简单的样例，但试想一下如果你需要在同一台服务器上，完美运行两个依赖于不同版本的Java、Python的应用。这将是一件多么让人头大的事儿，如果没丰富的经验很可能就玩脱了。幸运的是，在容器的世界里这两个应用即使依赖再冲突，他们也是相互隔绝的、互不干扰的。 [!TIP] 下面的内容也可以通过查看 关于Docker的几点常识 这篇文章来理解。 关键术语 了解下面这些术语可能会有助于你是用容器： docker - 第一也是最流行的容器runtime container - 运行在内存中的隔离沙盒，是镜像的运行状态 image - 可以理解为可以被docker运行的预先构建的系统镜像 volume - 用于在容器隔离沙盒外保存数据的地方 environment - 可用于配置容器隔离沙盒内环境变量的方法 关键概念 容器是完全由Linux内核创建的隔离沙盒环境。你也可以理解为这是虚拟机（虽然实际上他们两者并不相同）。Linux内核通过控制组（cgroups）控制对各种系统资源的访问。而我们则依靠docker来将这些复杂的概念转换为用户可以理解和使用的简单概念。 在默认情况下，正在运行的容器和系统环境是完全隔离的，如果你在容器内运行了一个web服务器，外界是无法访问容器内80和443的端口。除非我们使用 -p 来把容器内的端口映射到宿主机上。 ![WARNING] 例子中使用的 linuxserver/letsencrypt 镜像已经被 linuxserver/swag 替代，但不影响演示。 docker run -d --name=letsencrypt -p 80:80 -p 443:443 linuxserver/letsencrypt 了解上面这些关于端口（ports）、卷（volumes）、环境变量（environment）等概念将有助于通过docker部署一个可以运行的应用。对于我们开发者来说，这也能让有问题的容器与你的系统隔绝开来，不影响系统上的其他应用程式，这个容器出问题了，我们换下一个就可以。 容器是一个通过隔离沙盒安全地运行程序的绝妙方式。 powered by Gitbook该页面修订时间： 2020-10-16 15:44:50 "},"general/running-our-containers.html":{"url":"general/running-our-containers.html","title":"运行LinuxServer的容器","keywords":"","body":"运行LinuxServer的容器 镜像的结构 基础镜像 我们制作了几个用于构建我们主要程序的基础镜像，这些主要有以下两点好处： 多个不同的镜像使用相同依赖于相同的基础镜像，会减少意外的发生。 充分利用Docker的镜像分层系统，来减少主机上镜像的占用空间。在本地运行多个基于同一基础映像的容器将重复使用同一个基础镜像，不会再额外下载。 /config 卷 为了统一我们制作的镜像，我们为各个应用程式配置了相同的目录结构，所以我们的每个镜像内部都有/config 卷用于存储程序的配置文件。除了少数的几个特殊镜像外，其他的镜像我们都会将这个卷映射出来。 之所以这么做，是因为我们希望能用一个简单的方式回答最常被问的问题“程序的数据都保存在哪里？” - “都在 /config 里”。如果在创建容器的时候并没有映射此目录，那么你运行的容器的数据在容器被删除或重建后将一同消失。 [!TIP] 如果是通过portainer创建的容器，即使没有映射任何容器内的目录。portainer也会自动创建一个匿名卷来保存数据。 创建容器 通过我们的镜像创建容器时，你必须使用 docker create 或 docker run 。创建镜像的每一条命令都可以使用下面这种格式： docker create \\ --name= \\ -v :/config \\ -e PUID= \\ -e PGID= \\ -p : \\ linuxserver/ powered by Gitbook该页面修订时间： 2020-10-16 16:12:08 "},"general/docker-compose.html":{"url":"general/docker-compose.html","title":"Docker Compose","keywords":"","body":"Docker Compose 介绍 Compose是用于定义和运行多个docker应用程序的工具，你可以使用yaml文件来配置应用程序的服务，只用一条命令便可以启动配置中的所有服务。 安装 方式一（推荐）： 你可以通过运行我们的脚本基于我们的docker-compose镜像来安装docker-compose。只要下面这两条简单的命令，你就可以在你的系统上使用docker-compose： sudo curl -L --fail https://raw.githubusercontent.com/linuxserver/docker-docker-compose/master/run.sh -o /usr/local/bin/docker-compose sudo chmod +x /usr/local/bin/docker-compose 可以用下面的命令来更新docker-compose： docker pull linuxserver/docker-compose:\"${DOCKER_COMPOSE_IMAGE_TAG:-latest}\" docker image prune -f 如果要使用基于微型系统alpine制作的docker-compose镜像，你可以通过修改 .profile 文件，在其中设置一条环境变量： DOCKER_COMPOSE_IMAGE_TAG=alpine 。当然，你也可以把变量设置为 version-1.27.4 或 version-alpine-1.27.4 来获取特定版本的docker-compose。 方式二： 我们也在 这里 发布了docker-compose的二进制版本。其中有两个版本：一个是基于glibc系统的（如Ubuntu、Debian）；一个是基于musl系统的（如Alpine，被标记为 alpine 标签）。每一个版本都包含了 amd64、armhf、arm64的二进制文件。你可以通过下面这条命令把二进制文件下载到你的系统里并安装docker-compose： sudo curl -L --fail https://github.com/linuxserver/docker-docker-compose/releases/download/1.27.4-ls17/docker-compose-amd64 -o /usr/local/bin/docker-compose sudo chmod +x /usr/local/bin/docker-compose 启动单服务的方式 下面是用docker-compose部署linuxserver制作的容器的样例： version: \"2.1\" services: heimdall: image: linuxserver/heimdall container_name: heimdall volumes: - /home/user/appdata/heimdall:/config environment: - PUID: 1000 - PGID: 1000 - TZ=Europe/London ports: - 80:80 - 443:443 restart: unless-stopped 如果你将以上代码片段保存到名为 docker-compose.yml 的文件中，你可以在与文件相同的目录下使用 docker-compose up -d 来部署服务。其中 heimdall 镜像将被自动拉取，容器将被自动创建并启动。其中，up 意味着启动服务，-d 则意味着在后台运行。 如果你希望用其他目录或其他名称的yaml文件（如 heimdall.yml ），那么你可以在 -f 后指定文件的位置：docker-compose -f /path/to/heimdall.yml up -d 如果你希望停止服务，则使用 docker-compose down 或 docker-compose -f /path/to/heimdall.yml down 。所有通过该配置文件部署的容器将被停止并删除。 启动多服务的方式 你可以使用一个compose的yaml文件管理多个服务。 复制配置文件中 services: 下的内容到同一个文件中并使用 docker-compose up/down 命令，将可以启动/停止文件中的所有服务。 例：docker-compose.yml version: \"2.1\" services: heimdall: image: linuxserver/heimdall container_name: heimdall volumes: - /home/user/appdata/heimdall:/config environment: - PUID: 1000 - PGID: 1000 - TZ=Europe/London ports: - 80:80 - 443:443 restart: unless-stopped nginx: image: linuxserver/nginx container_name: nginx environment: - PUID=1000 - PGID=1000 - TZ=Europe/London volumes: - /home/user/appdata/nginx:/config ports: - 81:80 - 444:443 restart: unless-stopped mariadb: image: linuxserver/mariadb container_name: mariadb environment: - PUID=1000 - PGID=1000 - MYSQL_ROOT_PASSWORD=ROOT_ACCESS_PASSWORD - TZ=Europe/London volumes: - /home/user/appdata/mariadb:/config ports: - 3306:3306 restart: unless-stopped 这样，你就可以一下启动 heimdall、nginx、mariadb 这三个服务。 当你执行 docker-compose up -d 时，将首先使用本地的镜像，若本地中没有，则会自动拉取相关的镜像。然后将创建并启动这三个容器。执行 docker-compose down 时，所有的三个服务将被停止并删除容器（数据将被保留，因数据都以映射到本地保存）。 更新升级 如果你希望更新镜像并用相同的参数重新创建容器，那么使用docker-compose便会异常轻松。首先，我们使用 docker-compose pull 来更新所有的镜像。然后，执行 docker-compose up -d 后，将自动用更新后的镜像重新创建容器。如果某个容器已经是最新版，那么它将不会被更新，将保持不变。 同样的，如果你修改了yaml文件中的内容，并执行 docker-compose up -d ，那么只会改变yaml文件中配置的容器，其他容器不变。 将部署容器的代码定义在服务器上，是“Devops”的核心宗旨。使用docker-compose，可以有效避免直接使用docker run 命令时忘记某个参数的尴尬情况。 小贴士 docker-compose 默认使用当前目录下的 docker-compose.yml 文件，若没有该文件则会报错。我们可以使用bash aliases来提高效率。 创建 ~/.bash_aliases 文件并写入下面的内容： alias dcp='docker-compose -f /opt/docker-compose.yml ' alias dcpull='docker-compose -f /opt/docker-compose.yml pull' alias dclogs='docker-compose -f /opt/docker-compose.yml logs -tf --tail=\"50\" ' alias dtail='docker logs -tf --tail=\"50\" \"$@\"' 再将下面的代码加入 ~/.bashrc 中以用来启用上面的文件： if [ -f ~/.bash_aliases ]; then . ~/.bash_aliases fi 配置完成后，注销再登录后。你就可以使用 dcpull 或 dcp up -d 来管理你的容器了。 powered by Gitbook该页面修订时间： 2020-10-16 17:22:46 "},"general/understanding-puid-and-pgid.html":{"url":"general/understanding-puid-and-pgid.html","title":"什么是PUID和PGID","keywords":"","body":"什么是PUID和PGID [!NOTE] 虽然Docker目前已经支持了 --user 参数。但我们的镜像目前还不兼容，所以我们还是建议继续使用PUID和PGID。 为什么要用这个？ 因为Docker需要系统中管理网络、文件系统、进程的权限，所以通常是以 root 的身份在运行。这意味着，容器内的用户默认也是以 root 用户运行。这种高权限的访问，并不是日常使用中所推荐的，除非你对linux运维有着深入的理解。 另一个问题就是对容器映射出来的文件的管理。如果进程是以 root 身份运行，那么它所创建的文件的所有者都是 root 用户，这有可能会导致你没有权限去修改这些文件（如果你是以非root身份登陆服务器。） 而是用 PUID 和 PGID 允许我们将容器内的用户权限映射给宿主机上的用户。我们所有的容器都可以使用这种方法来映射用户权限。 使用变量 当使用我们的镜像创建容器时，确保你是用了 -e PUID 和 -e PGID： docker create --name=beets -e PUID=1000 -e PGID=1000 linuxserver/beets 如果使用 docker-compose ，把他们添加在 environment: 下面： environment: - PUID=1000 - PGID=1000 你很可能希望使用自己的 id，可以通过下面的命令来查询你当前用户的id。其中 uid 和 gid 分别对应 PUID 和 PGID： id $user powered by Gitbook该页面修订时间： 2020-10-16 17:53:16 "},"general/updating-our-containers.html":{"url":"general/updating-our-containers.html","title":"更新容器","keywords":"","body":"Updating our containers powered by Gitbook该页面修订时间： 2020-10-15 11:30:04 "},"general/volumes.html":{"url":"general/volumes.html","title":"卷（Volumes）","keywords":"","body":"Volumes powered by Gitbook该页面修订时间： 2020-10-15 11:30:04 "},"general/fleet.html":{"url":"general/fleet.html","title":"Fleet","keywords":"","body":"Fleet powered by Gitbook该页面修订时间： 2020-10-15 11:30:04 "},"general/swag.html":{"url":"general/swag.html","title":"部署SWAG","keywords":"","body":"SWAG setup powered by Gitbook该页面修订时间： 2020-10-15 11:30:04 "},"images/docker-airsonic.html":{"url":"images/docker-airsonic.html","title":"linuxserver/airsonic","keywords":"","body":"linuxserver/airsonic powered by Gitbook该页面修订时间： 2020-10-15 11:30:04 "}}